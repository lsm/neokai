/**
 * Scans packages/web/dist/ and generates packages/cli/src/embedded-assets.ts
 * with Bun file imports for embedding in compiled binaries.
 *
 * Usage: bun run scripts/generate-embedded-assets.ts
 */

import { readdirSync, statSync, writeFileSync } from 'node:fs';
import { join, relative, extname } from 'node:path';

const ROOT = join(import.meta.dir, '..');
const DIST_DIR = join(ROOT, 'packages/web/dist');
const OUTPUT_FILE = join(ROOT, 'packages/cli/src/embedded-assets.ts');

const MIME_TYPES: Record<string, string> = {
	'.html': 'text/html; charset=utf-8',
	'.js': 'application/javascript; charset=utf-8',
	'.css': 'text/css; charset=utf-8',
	'.json': 'application/json; charset=utf-8',
	'.svg': 'image/svg+xml',
	'.png': 'image/png',
	'.jpg': 'image/jpeg',
	'.jpeg': 'image/jpeg',
	'.gif': 'image/gif',
	'.ico': 'image/x-icon',
	'.webp': 'image/webp',
	'.woff': 'font/woff',
	'.woff2': 'font/woff2',
	'.ttf': 'font/ttf',
	'.eot': 'application/vnd.ms-fontobject',
	'.txt': 'text/plain; charset=utf-8',
	'.xml': 'application/xml',
	'.webmanifest': 'application/manifest+json',
};

// File extensions to skip (not needed in the binary)
const SKIP_EXTENSIONS = new Set(['.map']);

function sanitizeIdentifier(relativePath: string): string {
	return (
		'asset_' +
		relativePath
			.replace(/[^a-zA-Z0-9]/g, '_')
			.replace(/_+/g, '_')
			.replace(/^_|_$/g, '')
	);
}

function walkDir(dir: string): string[] {
	const files: string[] = [];
	for (const entry of readdirSync(dir)) {
		const full = join(dir, entry);
		if (statSync(full).isDirectory()) {
			files.push(...walkDir(full));
		} else {
			files.push(full);
		}
	}
	return files;
}

// Verify dist directory exists
try {
	statSync(DIST_DIR);
} catch {
	console.error(`Error: ${DIST_DIR} does not exist.`);
	console.error('Run "cd packages/web && bun run build" first.');
	process.exit(1);
}

// Scan dist directory
const allFiles = walkDir(DIST_DIR);
const imports: string[] = [];
const mapEntries: string[] = [];
let skipped = 0;

for (const absPath of allFiles) {
	const relPath = relative(DIST_DIR, absPath);
	const ext = extname(relPath);

	// Skip source maps and other unnecessary files
	if (SKIP_EXTENSIONS.has(ext)) {
		skipped++;
		continue;
	}

	const urlPath = '/' + relPath.replace(/\\/g, '/');
	const id = sanitizeIdentifier(relPath);
	const mime = MIME_TYPES[ext] || 'application/octet-stream';
	const importPath = '../../web/dist/' + relPath.replace(/\\/g, '/');

	imports.push(`import ${id} from "${importPath}" with { type: "file" };`);
	mapEntries.push(`\t["${urlPath}", { filePath: ${id}, mimeType: "${mime}" }],`);
}

const output = `// AUTO-GENERATED by scripts/generate-embedded-assets.ts -- DO NOT EDIT
${imports.join('\n')}

export interface EmbeddedAsset {
	filePath: string;
	mimeType: string;
}

export const embeddedAssets = new Map<string, EmbeddedAsset>([
${mapEntries.join('\n')}
]);
`;

writeFileSync(OUTPUT_FILE, output);
console.log(
	`Generated ${OUTPUT_FILE} with ${mapEntries.length} embedded assets (${skipped} source maps skipped)`
);
